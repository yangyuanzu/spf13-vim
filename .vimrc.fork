" Modeline and Notes {
" vim: set foldmarker={,} foldlevel=0 foldmethod=marker:
"
" Forked spf13-vim of perfectworks.
" }

" Environment {
    " Basic {
        set clipboard&
    " }
" }

" General {
    set enc=UTF-8
    set fileencodings=ucs-bom,utf-8,gbk
    set fileformats=unix,dos,mac
    set tags+=tags;
    set ambiwidth=double
    set laststatus=2
    set autowriteall
    set nospell
    set wildignore+=*-target,target
    set nu
" }

" Vim UI {
    colo molokai
" }

" Formatting {
    autocmd FileType css,less,vm,vim autocmd BufWritePre <buffer> :call setline(1,map(getline(1,"$"),'substitute(v:val,"\\s\\+$","","")'))
" }

" Complete {
    autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
    autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
    autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
    autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
    autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
    autocmd FileType ruby setlocal omnifunc=rubycomplete#Complete

    let g:ycm_global_ycm_extra_conf = '~/.vim/bundle/YouCompleteMe/cpp/ycm/.ycm_extra_conf.py'
    let g:ycm_key_list_select_completion = ['<c-n>', '<Down>']
    let g:ycm_key_list_previous_completion = ['<c-p>', '<Up>']

    hi cCustomFunc  guifg=yellowgreen
    hi cCustomClass guifg=#6DDEFE
" }

" Key (re)Mappings {
    " Unmap spf13 mappings {
        cunmap cwd

        vunmap <
        vunmap >
    " }

    " Paste yank register {
        nmap gp "0p
        nmap gP "0P
    " }

    " Start shell
    map <Leader>sh :sh<CR>

    " Emacs style command line course move {
        cmap <C-A> <Home>
        cmap <C-E> <End>
    " }

    " map double j to <esc>
    " imap <silent> jj <esc>:w<cr>
    " YouCompleteMe
    nnoremap <leader>jd :YcmCompleter GoToDefinitionElseDeclaration<CR>

    " F7/F8 to jump to next/prev diff / location-list {
    " @see http://vim.wikia.com/wiki/Selecting_changes_in_diff_mode
        if &diff
            let g:origCursorPos=getpos('.')
            autocmd WinEnter * :call setpos('.', g:origCursorPos)
            autocmd WinLeave * :let g:origCursorPos=getpos('.')
            nmap <F7> [c
            nmap <F8> ]c
        else
            map <F7> :lprev<cr>
            map <F8> :lnext<cr>
        endif
    " }

    " Visual block search {
        function! VisualSearch(direction) range
            let l:saved_reg = @"
            execute "normal! vgvy"

            let l:pattern = escape(@", '\\/.*$^~[]')
            let l:pattern = substitute(l:pattern, "\n$", "", "")

            if a:direction == 'b'
                execute "normal ?" . l:pattern . ""
            elseif a:direction == 'f'
                execute "normal /" . l:pattern . ""
            endif

            let @/ = l:pattern
            let @" = l:saved_reg
        endfunction

        vnoremap <silent> * :call VisualSearch('f')<CR>
        vnoremap <silent> # :call VisualSearch('b')<CR>
    " }

    " Swap 0 and ^ {
        nnoremap 0 ^
        nnoremap ^ 0
        nnoremap d0 d^
        nnoremap d^ d0
        nnoremap c0 c^
        nnoremap c^ c0
        nnoremap s0 s^
        nnoremap s^ s0
        nnoremap y0 y^
        nnoremap y^ y0
    " }
" }

" Plugins {
    " SnipMate {
        " Setting the author var
        " If forking, please overwrite in your .vimrc.local file
        let g:snips_author = 'zhangyc <zhangyc@fenbi.com>'
    " }

    " CtrlP {
        nmap <silent> <C-j> :CtrlPTag<cr>
        nmap <silent> <space> :CtrlPMRUFiles<cr>

        let g:ctrlp_regexp = 1
        let g:ctrlp_cmd = 'CtrlPMixed'
        let g:ctrlp_max_files = 10000
    " }

    " Switch.vim {
        nnoremap - :Switch<cr>
    " }

    " NerdTree {
        unmap <leader>e
    " }

    " Ack {
        nmap <F3> :LAck <C-R><C-W>
    " }

    " SnipMate {
        function! ToggleSnipple()
            if &ft == 'snippet'
                w!
                edit #
                bdelete #
            else
                SnipMateOpenSnippetFiles
            endif
        endfunction

        nmap <F9> :call ToggleSnipple()<CR>
    " }

    " ZenCoding {
        let g:user_zen_leader_key = '<c-k>'
    " }

    " BufExplorer {
        unmap <leader>b
    " }

    " Generate JavaScript tags {
        function! GenerateTag()
            let file = fnamemodify(findfile('jstags', '.;'), ':p')
            if executable(file)
                execute ':silent !' . file
            endif
        endfunction

        autocmd BufWritePost *.js call GenerateTag()
    " }

    " Sync edit file by bsync {
    "    autocmd BufWritePost * call system('bsync '.expand('%:p').' &')
    " }
" }

" Filetype {
    " Git Commit {
        au BufNewFile,BufRead COMMIT_EDITMSG setlocal spell
    " }
" }

" Path {
    set path+=.,/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk/usr/include,/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk/usr/include/c++/4.2.1
" }

" Google C++ {
" Detect if the current file type is a C-like language.
autocmd FileType,BufNewFile,BufRead c,cpp call SetupForCLang()

" Configuration for C-like languages.
function! SetupForCLang()
    set colorcolumn=80
    hi ColorColumn ctermbg=black guibg=black
    " Highlight lines longer than 80 characters.
    " au BufWinEnter * let w:m2=matchadd('ErrorMsg', '\%>80v.\+', -1)

    " Alternately, uncomment these lines to wrap at 80 characters.
    " setlocal textwidth=80
    " setlocal wrap

    " Use 2 spaces for indentation.
    setlocal shiftwidth=2
    setlocal tabstop=2
    setlocal softtabstop=2
    setlocal expandtab

    " Configure auto-indentation formatting.
    setlocal cindent
    setlocal cinoptions=h1,l1,g1,t0,i4,+4,(0,w1,W4
    setlocal indentexpr=GoogleCppIndent()
    let b:undo_indent = "setl sw< ts< sts< et< tw< wrap< cin< cino< inde<"

    " Uncomment these lines to map F5 to the CEF style checker. Change the path to match your system.
    " map! <F5> <Esc>:!python ~/code/chromium/src/cef/tools/check_style.py %:p 2> lint.out<CR>:cfile lint.out<CR>:silent !rm lint.out<CR>:redraw!<CR>:cc<CR>
    " map  <F5> <Esc>:!python ~/code/chromium/src/cef/tools/check_style.py %:p 2> lint.out<CR>:cfile lint.out<CR>:silent !rm lint.out<CR>:redraw!<CR>:cc<CR>
endfunction

" From https://github.com/vim-scripts/google.vim/blob/master/indent/google.vim
function! GoogleCppIndent()
    let l:cline_num = line('.')

    let l:orig_indent = cindent(l:cline_num)

    if l:orig_indent == 0 | return 0 | endif

    let l:pline_num = prevnonblank(l:cline_num - 1)
    let l:pline = getline(l:pline_num)
    if l:pline =~# '^\s*template' | return l:pline_indent | endif

    " TODO: I don't know to correct it:
    " namespace test {
    " void
    " ....<-- invalid cindent pos
    "
    " void test() {
    " }
    "
    " void
    " <-- cindent pos
    if l:orig_indent != &shiftwidth | return l:orig_indent | endif

    let l:in_comment = 0
    let l:pline_num = prevnonblank(l:cline_num - 1)
    while l:pline_num > -1
        let l:pline = getline(l:pline_num)
        let l:pline_indent = indent(l:pline_num)

        if l:in_comment == 0 && l:pline =~ '^.\{-}\(/\*.\{-}\)\@<!\*/'
            let l:in_comment = 1
        elseif l:in_comment == 1
            if l:pline =~ '/\*\(.\{-}\*/\)\@!'
                let l:in_comment = 0
            endif
        elseif l:pline_indent == 0
            if l:pline !~# '\(#define\)\|\(^\s*//\)\|\(^\s*{\)'
                if l:pline =~# '^\s*namespace.*'
                    return 0
                else
                    return l:orig_indent
                endif
            elseif l:pline =~# '\\$'
                return l:orig_indent
            endif
        else
            return l:orig_indent
        endif

        let l:pline_num = prevnonblank(l:pline_num - 1)
    endwhile

    return l:orig_indent
endfunction
" }
